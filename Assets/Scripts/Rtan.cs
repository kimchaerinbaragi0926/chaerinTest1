using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Rtan : MonoBehaviour
{
    float direction = 0.05f; // 오늘(2025년 9월 23일) 이 부분을 추가합니다: float direction = 0.05f; 시작.
    // direction은 캐릭터가 움직이는 방향을 나타낸다.
    // direction의 값이 양수이면, 캐릭터가 오른쪽으로 움직이고, 음수이면, 캐릭터가 왼쪽으로 움직인다.
    // direction의 값이 0이면, 캐릭터가 움직이지 않는다.
    // float direction = 0.05f;를 사용하여, transform.position += Vector3.right * direction;을 작성할 수 있다.
    // direction의 값을 변경하여, 캐릭터가 움직이는 방향을 변경할 수 있다.
    // 예를 들어, direction의 값을 -0.05f로 변경하면, 캐릭터가 왼쪽으로 움직인다.
    // direction의 값을 0으로 변경하면, 캐릭터가 움직이지 않는다.
    // direction의 값을 0.1f로 변경하면, 캐릭터가 오른쪽으로 더 빠르게 움직인다.
    // direction의 값을 -0.1f로 변경하면, 캐릭터가 왼쪽으로 더 빠르게 움직인다.
    // direction의 값을 0.01f로 변경하면, 캐릭터가 오른쪽으로 더 느리게 움직인다.
    // direction의 값을 -0.01f로 변경하면, 캐릭터가 왼쪽으로 더 느리게 움직인다.
    // direction의 값을 변경하는 방법은 여러 가지가 있다.
    // 예를 들어, 키보드 입력을 받아서 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 마우스 입력을 받아서 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 게임 내의 이벤트를 받아서 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 시간에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 상태에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 위치에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 속도에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 가속도에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 회전에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 크기에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 색상에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 투명도에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 애니메이션에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 사운드에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 이펙트에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 스크립트에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 컴포넌트, 즉 Rigidbody, Collider, Animator 등에 따라 direction의 값을 변경할 수 있다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 부모 오브젝트에 따라 direction의 값을 변경할 수 있다.
    // 부모 오브젝트는 '다른 오브젝트를 포함하는 오브젝트'라고 생각하면 된다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 자식 오브젝트에 따라 direction의 값을 변경할 수 있다.
    // 자식 오브젝트는 '다른 오브젝트에 포함되는 오브젝트'라고 생각하면 된다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 태그에 따라 direction의 값을 변경할 수 있다.
    // 태그는 '오브젝트를 구분하는 이름'이라고 생각하면 된다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 레이어에 따라 direction의 값을 변경할 수 있다.
    // 레이어는 '오브젝트를 구분하는 층'이라고 생각하면 된다.
    // direction의 값을 변경하는 또 다른 방법은, 캐릭터의 이름에 따라 direction의 값을 변경할 수 있다.
    // 이름은 '오브젝트를 구분하는 이름'이라고 생각하면 된다.
    // 한 줄 요약: direction은 캐릭터가 움직이는 방향을 나타낸다.
    // int number = 1;(필요없는 부분이지만 수업을 위해 사용함.)
    // string str = "안녕"(필요없는 부분이지만 수업을 위해 사용함.)

    SpriteRenderer renderer; // 오늘(2025년 9월 23일) 이 부분을 추가합니다: SpriteRenderer renderer; 시작.
    // 오늘 마침.

    // Start is called before the first frame update
    void Start()
    {

        Application.targetFrameRate = 60;
        renderer = GetComponent<SpriteRenderer>(); // 오늘(2025년 9월 23일) 이 부분을 추가합니다: renderer = GetComponent<SpriteRenderer>(); 시작(단독). 이때, '시작(단독)'은 시작과 끝을 동시에 나타내기로 함. '시작(단독)'이 아닌 '시작'은 뒤에 끝이 따로 있음.
        // Debug.Log("안녕");(필요없는 부분이지만 수업을 위해 사용함.)
        // Application.targetFrameRate = 60;는 게임의 프레임 수를 60으로 설정한다.
        // 위의 문장을 쉽게 말하면, 게임이 1초에 60프레임으로 실행된다는 뜻이다.
        // '60'프레임이란 캐릭터가 화면에서 1초에 60번 움직인다는 뜻이다.
        // Application은 유니티에서 제공하는 클래스이다.
        // '유니티에서 제공하는 클래스'란 유니티에서 미리 만들어 놓은 클래스라는 뜻이다.
        // 클래스를 쉽게 말하면, '설계도'라고 생각하면 된다.
        // 따라서 이것을 쉽게 말하면, '유니티에서 미리 만들어 놓은 설계도'라는 뜻이다.
        // 한 줄 요약: Application은 유니티에서 미리 만들어 놓은 설계도이다.
        // 
        // targetFrameRate는 Application 클래스의 속성(property)이다.
        // 위의 문장을 쉽게 말하면, 'Application 클래스의 targetFrameRate 속성'이라는 뜻이다.
        // 속성을 쉽게 말하면, '특징'이라고 생각하면 된다.
        // 따라서 이것을 쉽게 말하면, 'Application 클래스의 특징'이라는 뜻이다.
        // 결론적으로, Application.targetFrameRate = 60;는 '유니티에서 미리 만들어 놓은 설계도인 Application 클래스의 특징인 targetFrameRate 속성을 60으로 설정한다'라는 뜻이다.
        // 한 줄 요약: Application.targetFrameRate = 60;는 게임이 1초에 60프레임으로 실행된다는 뜻이다.
        // Debug.Log("안녕");는 콘솔 창에 "안녕"이라는 메시지를 출력한다.
        // Debug는 유니티에서 제공하는 클래스이다.
        // Log는 Debug 클래스의 메서드(method)이다.
        // 메서드를 쉽게 말하면, '기능'이라고 생각하면 된다.
        // 따라서 이것을 쉽게 말하면, 'Debug 클래스의 기능'이라는 뜻이다.
        // 결론적으로, Debug.Log("안녕");는 '유니티에서 미리 만들어 놓은 설계도인 Debug 클래스의 기능인 Log 메서드를 사용하여 콘솔 창에 "안녕"이라는 메시지를 출력한다'라는 뜻이다.
        // 한 줄 요약: Debug.Log("안녕");는 콘솔 창에 "안녕"이라는 메시지를 출력한다.
        // 
        // 콘솔 창은 유니티 에디터의 하단에 있는 창이다. 콘솔 창은 게임이 실행되는 동안 발생하는 오류 메시지나 디버그 메시지를 출력하는 데 사용된다.
        // "안녕"은 출력할 메시지이다. 이 메시지는 큰따옴표("")로 감싸야 한다.
        // 만약 큰따옴표("")로 감싸지 않으면, 오류가 발생한다.
        // 왜냐하면, 큰따옴표("")로 감싸지 않으면, "안녕"이 변수로 인식되기 때문이다.
        // 여기에서의 변수는 '값을 저장하는 공간'이라고 생각하면 된다.
        // 따라서 이것을 쉽게 말하면, "안녕"이라는 값을 저장하는 공간이 없기 때문에 오류가 발생한다는 뜻이다.
        // 이러한 이유로 "안녕"은 반드시 큰따옴표("")로 감싸야 한다.
        // 한 줄 요약: "안녕"은 출력할 메시지이다. 이 메시지는 큰따옴표("")로 감싸야 한다.
        // 
        // Debug.Log("안녕");는 게임이 시작될 때 한 번만 실행된다.
        // 왜냐하면, Start() 메서드는 게임이 시작될 때 한 번만 호출되기 때문이다.
        // 따라서, 콘솔 창에는 게임이 시작될 때 한 번만 "안녕"이라는 메시지가 출력된다.
        // 만약 게임이 실행되는 동안 계속해서 "안녕"이라는 메시지를 출력하고 싶다면, Update() 메서드에 Debug.Log("안녕");를 작성하면 된다.
        // Update() 메서드는 매 프레임마다 호출되기 때문이다.
        // 따라서, 콘솔 창에는 매 프레임마다 "안녕"이라는 메시지가 출력된다.
        // 매 프레임마다 "안녕"이라는 메시지가 출력된다는 것은, 게임이 1초에 60프레임으로 실행된다면, 1초에 60번 "안녕"이라는 메시지가 출력된다는 뜻이다.
        // 하지만, 이렇게 하면 콘솔 창이 너무 많은 메시지로 가득 차게 된다.
        // 콘솔 창이 너무 많은 메시지로 가득 차게 되면, 나중에 오류 메시지를 찾기가 어려워진다.
        // 또한, 콘솔 창이 너무 많은 메시지로 가득 차게 되면, 게임의 성능이 저하될 수 있다.
        // 게임의 성능이 저하된다는 것은 게임이 느려진다는 뜻이다.
        // 게임의 성능을 저하시키지 않으면서 디버깅을 하기 위해서는 Debug.Log() 메서드를 적절히 사용해야 한다.
        // 여기서 디버깅은 '오류를 찾고 수정하는 과정'이라고 생각하면 된다.
        // 만약 디버깅을 하지 않는다면, 게임이 제대로 작동하지 않을 수 있다.
        // 여기서 적절히 사용한다는 것은, 게임이 시작될 때 한 번만 사용하거나, 특정 이벤트가 발생했을 때만 사용하는 것을 말한다.
        // 그래서 보통은 Start() 메서드에 Debug.Log("안녕");를 작성한다.
        // 한 줄 요약: Debug.Log("안녕");는 게임이 시작될 때 한 번만 "안녕"이라는 메시지를 출력한다.
        //
        // 유니티에서, Void는 쉽게 말하면, '반환값이 없는 함수'라고 생각하면 된다.
        // 유니티는 C# 언어를 사용한다.
        // 유니티는 다른 언어를 사용하지 않는다.
        // 유니티가 C# 언어를 사용한다는 것은, 유니티에서 작성하는 스크립트는 모두 C# 언어로 작성해야 한다는 뜻이다.
        // 유니티가 사용하는 C#을 '유니티 C#'이라고 부르기도 한다.
        // 유니티 C#은 일반적인 C#과 거의 동일하다.
        // 유니티 C#을 잘 모르는 사람이 일반적인 C#을 배워도 유니티 C#을 사용하는 데 큰 문제가 없다.
        // 유니티를 잘 모르는 사람이 C#을 쉽게 공부하려면, C#의 기본 문법을 공부하는 것이 좋다.
        // C#의 기본 문법을 공부하는 데는 여러 가지 방법이 있다.
        // 가장 쉬운 방법은 인터넷에서 C#의 기본 문법을 검색하는 것이다.
        // C#의 기본 문법을 공부하는 또 다른 방법은 C# 관련 서적을 읽는 것이다.
        // C#의 기본 문법을 공부하는 또 다른 방법은 C# 관련 강의를 듣는 것이다.
        // 한 줄 요약: 유니티는 C# 언어를 사용한다.
        //
        // Start()와 Update()는 반환값이 없는 함수라는 뜻이다.
        // 반환값이 없는 함수는 값을 반환하지 않는 함수라는 뜻이다.
        // 함수는 '특정 작업을 수행하는 코드의 집합'이라고 생각하면 된다.
        // 따라서, Start()와 Update()는 특정 작업을 수행하는 코드의 집합이라는 뜻이다.
        // void 뒤의 Start()와 Update()는 함수의 이름이다.
        // 함수의 이름은 개발자가 임의로 정할 수 있다.
        // 임의로 정한다는 것은 개발자가 마음대로 정할 수 있다는 뜻이다.
        // Start()의 뜻은 유니티에서는 게임이 시작될 때 한 번 호출되는 함수라는 뜻이다.
        // 반면, Update()의 뜻은 유니티에서는 매 프레임마다 호출되는 함수라는 뜻이다.
        // 한 줄 요약: Start()와 Update()는 반환값이 없는 함수이다.
        // 
        // direction = -0.05f; // 오늘(2025년 9월 23일) 이 부분을 추가합니다: direction = 0.05f; 시작(단독).(필요없는 부분이지만 수업을 위해 사용함.)
    }

    // Update is called once per frame
    // Update is called once per frame을 한국어로 쉽게 말하면, 'Update는 매 프레임마다 호출된다'라는 뜻이다.
    // 즉, Update() 메서드는 매 프레임마다 호출된다는 뜻이다.
    // 따라서, Update() 메서드에 작성한 코드는 매 프레임마다 실행된다는 뜻이다.
    // 한 줄 요약: Update is called once per frame은 'Update는 매 프레임마다 호출된다'라는 뜻이다.
    void Update()
    {
        if (Input.GetMouseButtonDown(0)) // 오늘(2025년 9월 23일) 이 부분을 추가합니다: if (Input.GetMouseButtonDown(0)) 시작.
            // Input은 유니티에서 제공하는 클래스이다.
            // GetMouseButtonDown은 Input 클래스의 메서드(method)이다.
            // GetMouseButtonDown의 뜻은 '마우스 버튼이 눌렸는지 여부를 반환한다'라는 뜻이다.
            // GetMouseButtonDown(0)은 마우스 왼쪽 버튼이 눌렸는지 여부를 반환한다는 뜻이다.
            // GetMouseButtonDown(1)은 마우스 오른쪽 버튼이 눌렸는지 여부를 반환한다는 뜻이다.
            // GetMouseButtonDown(2)은 마우스 가운데 버튼이 눌렸는지 여부를 반환한다는 뜻이다.
            // 여부를 반환한다는 것은, true 또는 false 값을 반환한다는 뜻이다.
            // 반환한다는 것은, '어떤 값을 돌려준다'라는 뜻이다.
            // '어떤 값을 돌려준다'라는 뜻은, '어떤 값을 함수의 결과로 돌려준다'라는 뜻이다.
            // 따라서, GetMouseButtonDown(0)은 마우스 왼쪽 버튼이 눌렸으면 true 값을 반환하고, 눌리지 않았으면 false 값을 반환한다는 뜻이다.
            // GetMouseButtonDown()를 다르게 쓰는 방법은 Input.GetMouseButtonDown()이다.
            // 즉, Input.GetMouseButtonDown(0)와 GetMouseButtonDown(0)는 동일한 값을 나타낸다.
            // 두 코드는 동일한 값을 나타내지만, Input.GetMouseButtonDown(0)를 사용하는 것이 더 명확하다.
            // 이때 인풋을 쓰지 않고 GetMouseButtonDown(0)만 쓰면, 오류가 발생한다.
            // 한 줄 요약: Input.GetMouseButtonDown(0)은 마우스 왼쪽 버튼이 눌렸는지 여부를 반환한다는 뜻이다.
            
            // if문은 조건문이다.
            // 조건문은 '특정 조건에 따라 코드를 실행하는 문장'이라고 생각하면 된다.
            // 따라서, if문은 특정 조건에 따라 코드를 실행한다는 뜻이다.
            // if문 뒤의 괄호() 안에는 조건식이 들어간다.
            // 조건식은 '참 또는 거짓을 판단하는 식'이라고 생각하면 된다.
            // 따라서, 조건식은 참 또는 거짓을 판단한다는 뜻이다.
            // 조건식의 결과가 참이면, if문 뒤의 중괄호{} 안에 있는 코드가 실행된다.
            // 조건식의 결과가 거짓이면, if문 뒤의 중괄호{} 안에 있는 코드는 실행되지 않는다.
            // if문 뒤의 중괄호{}가 없으면, if문 뒤의 한 줄의 코드만 실행된다.
            // if문 뒤의 괄호가 없으면, 오류가 발생한다.
            // 한 줄 요약: if문은 특정 조건에 따라 코드를 실행한다는 뜻이다.

        {
            direction *= -1; // direction = direction * -1;과 동일한 코드이다. 즉, direction의 값을 반대로 바꾼다는 뜻이다.
            // 이것을 쉽게 말하면, 캐릭터가 움직이는 방향을 반대로 바꾼다는 뜻이다.
            // direction의 값이 양수이면, 캐릭터가 오른쪽으로 움직이고, 음수이면, 캐릭터가 왼쪽으로 움직인다.
            // direction의 값이 0이면, 캐릭터가 움직이지 않는다.
            // 따라서, direction의 값을 반대로 바꾸면, 캐릭터가 움직이는 방향이 반대로 바뀐다는 뜻이다.
            // 참과 거짓 두 가지 값만 가지는 것을 한국어로 불린형이라고 한다.
            // 참과 거짓 두 가지 값만 가지는 것을 영어로 Boolean이라고 한다.
            renderer.flipX = !renderer.flipX; // renderer.flipX = true;와 renderer.flipX = false;를 번갈아가면서 실행한다는 뜻이다.
            // renderer.flipX = true;는 캐릭터가 왼쪽을 바라보도록 설정한다는 뜻이다.
            // renderer.flipX = false;는 캐릭터가 오른쪽을 바라보도록 설정한다는 뜻이다.
            // 따라서, renderer.flipX = !renderer.flipX;는 캐릭터가 움직이는 방향에 따라 좌우로 뒤집힌다는 뜻이다.
            // renderer.flipX의 값이 true이면, 캐릭터가 왼쪽을 바라보고, false이면, 캐릭터가 오른쪽을 바라본다.
            // 이때 '!'는 '반대'라는 뜻이다.
            // 따라서, renderer.flipX = !renderer.flipX;는 renderer.flipX의 값을 반대로 바꾼다는 뜻이다.
            // 즉, !로 인하여, renderer.flipX의 값이 true이면, false로 바뀌고, false이면, true로 바뀐다는 뜻이다.
            // 한 줄 요약: renderer.flipX = !renderer.flipX;는 캐릭터가 움직이는 방향에 따라 좌우로 뒤집힌다. 끝.
        }

        if (transform.position.x > 2.6f) // 오늘(2025년 9월 23일) 이 부분을 추가합니다: if(transform.pisition.x > 2.6f) 시작.
        {
            renderer.flipX = true; // 캐릭터가 왼쪽을 바라보도록 설정
            direction = -0.05f;
        }

        if(transform.position.x < -2.6f) // 오늘(2025년 9월 23일) 이 부분을 추가합니다: if(transform.pisition.x < -2.6f) 시작.
        {
            renderer.flipX = false; // 캐릭터가 오른쪽을 바라보도록 설정
            direction = 0.05f;
        }
        // 오늘(2025년 9월 23일) 이 부분을 추가합니다: if(transform.pisition.x > 2.6f)와 if(transform.pisition.x < -2.6f)는 캐릭터가 오른쪽 끝과 왼쪽 끝에 도달했을 때, 방향을 반대로 바꾸는 역할을 한다. 시작.
        // transform.position.x는 캐릭터의 현재 위치의 x좌표를 나타낸다.
        // 캐릭터가 오른쪽 끝에 도달했을 때, direction의 값을 -0.05f로 변경하여, 캐릭터가 왼쪽으로 움직이게 한다.
        // 캐릭터가 왼쪽 끝에 도달했을 때, direction의 값을 0.05f로 변경하여, 캐릭터가 오른쪽으로 움직이게 한다.
        // 캐릭터가 오른쪽 끝에 도달했는지 확인하는 방법은 transform.position.x > 2.6f이다.
        // 캐릭터가 왼쪽 끝에 도달했는지 확인하는 방법은 transform.position.x < -2.6f이다.
        // 이때 2.6f와 -2.6f는 캐릭터가 움직일 수 있는 범위를 나타낸다.
        // 캐릭터가 움직일 수 있는 범위는 개발자가 임의로 정할 수 있다.
        // 유니티에서 화면의 크기가 760*1280 즉 가로 760, 세로 1280이면, 캐릭터가 좌우로 움직일 수 있는 최대의 범위는 -3.8f에서 3.8f이다.
        // 따라서, 캐릭터가 좌우로 움직일 수 있는 범위를 -2.6f에서 2.6f로 설정하면, 캐릭터가 화면의 좌우 끝에서 약간 안쪽으로 움직일 수 있다.
        // 만약 if(transform.position.x > 2.6f) 및 if(transform.position.x > 2.6f)를 if(transform.position.x > 3.8f) 및 if(transform.position.x < -3.8f)로 변경하면, 캐릭터가 화면의 좌우 끝에서 딱 맞게 움직일 수 있다.
        // 이떄 캐릭터의 위치가 3.8f 또는 -3.8f가 되면, 캐릭터는 화면에서 보이지 않게 된다.
        // 캐릭터를 화면에서 보이게 하려면, 캐릭터의 위치가 3.8f 또는 -3.8f가 되기 전에 방향을 반대로 바꾸어야 한다.
        // 따라서, 캐릭터가 화면에서 보이게 하려면, if(transform.position.x > 2.6f) 및 if(transform.position.x < -2.6f)를 사용해야 한다.
        // 한 줄 요약: if(transform.position.x > 2.6f)와 if(transform.position.x < -2.6f)는 캐릭터가 오른쪽 끝과 왼쪽 끝에 도달했을 때, 방향을 반대로 바꾸는 역할을 한다. 끝.
        //
        // 오늘 (2025년 9월 23일) 이 부분을 추가합니다: Hierarchy 창에서 캐릭터 오브젝트를 선택한 후, Inspector 창에서 Sprite Renderer의 Flip X를 체크하면, 캐릭터가 좌우로 뒤집힌다. 시작.
        // 캐릭터가 오른쪽으로 움직일 때는 Flip X를 체크하지 않고, 왼쪽으로 움직일 때는 Flip X를 체크하면, 캐릭터가 움직이는 방향에 따라 좌우로 뒤집힌다.
        // 유니티의 카메라의 입장에서 캐릭터가 오른쪽을 바라볼 때는 Flip X를 체크하지 않고, 왼쪽을 바라볼 때는 Flip X를 체크하면, 캐릭터가 움직이는 방향에 따라 좌우로 뒤집힌다.
        // 캐릭터가 오른쪽을 바라보고 있을 때, 캐릭터가 왼쪽으로 움직일 때만 방향을 반대로 바꾸도록 코드를 작성하려면 다음과 같이 작성하면 된다.
        // if(transform.position.x > 2.6f && direction > 0)
        // {
        //     direction = -0.05f;
        //     GetComponent<SpriteRenderer>().flipX = true; // 캐릭터가 왼쪽을 바라보도록 설정
        // 만약 플립 X를 체크하고 싶지 않다면, GetComponent<SpriteRenderer>().flipX = true;를 제거하면 된다.
        // 반대로 이 코드를 쓰고 플립 X를 체크한 상태라면, 캐릭터가 오른쪽을 바라볼 때는 좌우가 뒤집힌 상태로, 캐릭터가 왼쪽을 바라볼 때는 좌우가 뒤집히지 않은 상태로 움직이게 된다.
        // 이것을 쉽게 말하면, 캐릭터가 오른쪽을 바라볼 때는 거꾸로 움직이고, 캐릭터가 왼쪽을 바라볼 때는 정상적으로 움직인다는 뜻이다.
        // 이것은 캐릭터가 움직이는 방향과 캐릭터가 바라보는 방향이 일치하지 않는다는 뜻이다.
        // }
        // if(transform.position.x < -2.6f && direction < 0)
        // {
        //     direction = 0.05f;
        //     GetComponent<SpriteRenderer>().flipX = false; // 캐릭터가 오른쪽을 바라보도록 설정
        // 만약 플립 X를 체크하고 싶지 않다면, GetComponent<SpriteRenderer>().flipX = false;를 제거하면 된다.
        // 반대로 이 코드를 쓰고 플립 X를 체크한 상태라면, 캐릭터가 오른쪽을 바라볼 때는 좌우가 뒤집힌 상태로, 캐릭터가 왼쪽을 바라볼 때는 좌우가 뒤집히지 않은 상태로 움직이게 된다.
        // 이것을 쉽게 말하면, 캐릭터가 오른쪽을 바라볼 때는 거꾸로 움직이고, 캐릭터가 왼쪽을 바라볼 때는 정상적으로 움직인다는 뜻이다.
        // 이것은 캐릭터가 움직이는 방향과 캐릭터가 바라보는 방향이 일치하지 않는다는 뜻이다.
        // }
        // 오늘 (2025년 9월 23일) 이 부분을 추가합니다: Hierarchy 창에서 캐릭터 오브젝트를 선택한 후, Inspector 창에서 Sprite Renderer의 Flip X를 체크하면, 캐릭터가 좌우로 뒤집힌다. 끝.

        transform.position += Vector3.right * direction; // 오늘(2025년 9월 23일) 이 부분을 수정합니다: transform.position += Vector3.right * 0.05f;를 transform.position += Vector3.right * direction;로 수정.
        // transform.position += Vector3.right는 캐릭터가 움직이려는 방향을 나타낸다.
        // * 0.05f는 캐릭터가 움직이는 속도를 나타낸다. * 뒤의 숫자는 1보다 작을수록 캐릭터의 속도가 느려진다.
        // f는 float형을 나타낸다. float형은 소수점을 포함한 숫자를 나타낸다(float에서 f 반드시 써야 함!). 반면 int형은 소수점을 포함하지 않은 숫자를 나타낸다.
        // 즉, 1, 2, 3 등 정수만 나타낸다.
        // float형은 1.0, 2.5, 3.14 등 소수점을 포함한 숫자를 나타낸다.
        // 따라서, 0.05f는 float형 숫자이다.
        // 이때 f를 사용하지 않고 float형 숫자를 나타내면, 오류가 발생한다.
        // 왜냐하면, 소수점을 포함한 숫자는 기본적으로 double형으로 인식되기 때문이다.
        // double형은 float형보다 더 큰 범위의 숫자를 나타낸다.
        // 알고 보면, double형은 float형보다 더 많은 메모리를 사용한다.
        // 이것은 저장 공간을 더 많이 차지한다는 뜻이다.
        // 저장 공간을 많이 차지할수록, 프로그램의 성능이 저하될 수 있다.
        // 프로그램의 성능이 저하된다는 것은 프로그램이 느려진다는 뜻이다.
        // 이렇게 하면, 게임의 속도는 느려진다.
        // 게임의 속도를 빠르게 하려면, float형을 사용하는 것이 좋다.
        // 따라서, 소수점을 포함한 숫자를 나타낼 때는 반드시 f를 사용하여 float형으로 나타내야 한다.
        // 반대로, 더블형의 숫자를 나타내려면, f를 사용하지 않고 숫자를 나타내면 된다.
        // 더블형의 숫자를 나타내는 다른 방법은 d를 사용하는 것이다.
        // 예를 들어, 0.05d는 double형 숫자이다.
        // 그리고 0.05는 double형 숫자이다.
        // 또한, 0.05f는 float형 숫자이다.
        // 즉, 0.05, 0.05d, 0.05f는 각각 double형, double형, float형 숫자이다.
        // float형은 4바이트의 메모리를 사용하고, double형은 8바이트의 메모리를 사용한다.
        // 즉, double형은 float형보다 2배 더 많은 메모리를 사용한다.
        // 0.05d, 0.05f의 용량의 차이는 4바이트이다. 4바이트는 32비트이다.
        // 32비트는 2의 32제곱, 즉 약 42억 개의 숫자를 나타낼 수 있다.
        // 이것을 생각할 때, 7자리의 숫자를 나타낼 때는 float형을 사용하고, 15자리 이상의 숫자를 나타낼 때는 double형을 사용하는 것이 좋다.
        // 예를 들어, 3.141592는 float형으로 나타낼 수 있지만, 3.141592653589793은 double형으로 나타내야 한다.
        // float가 아닌 double형을 사용하는 경우는 거의 없다.
        // double형을 한국어로 말하면, '배정밀도 부동소수점'이라고 한다.
        // 반면, float형을 한국어로 말하면, '단정밀도 부동소수점'이라고 한다.
        // 이때의 정밀도는 '숫자를 얼마나 정확하게 나타낼 수 있는가'라는 뜻이다.
        // 배정밀도의 배는 일반적으로 2배를 의미한다.
        // 단정밀도의 단은 일반적으로 1배를 의미한다.
        // 부동소수점은 '소수점의 위치가 고정되어 있지 않다'라는 뜻이다.
        // 부동소수점의 부동은 '떠다닌다'라는 뜻이다.
        // 그리고, 부동소수점의 반대말은 고정소수점이다.
        // 고정소수점은 '소수점의 위치가 고정되어 있다'라는 뜻이다.
        // 유니티에서 반동소수점은 거의 사용하지 않는다.
        // 반동소수점을 사용하는 경우는 거의 없지만, 사용의 예로, 정확한 물리 계산이 필요한 경우가 있다.
        // 예를 들어, 우주 시뮬레이션 게임에서 매우 큰 거리와 속도를 다룰 때, double형이 필요할 수 있다.
        // 즉, 더블형은 반동소수점이라고 할 수 있다.
        // 지구와 태양 사이의 거리나, 빛의 속도와 같은 매우 큰 숫자를 다룰 때 double형이 필요할 수 있다.
        // 지구와 태양 사이의 거리는 약 1억 5천만 킬로미터이다. 천문학적으로는 1.5억 킬로미터를 1.5e+08킬로미터라고 표현한다.
        // 1.5e+08과 1.5e+08f는 다른 값이다.
        // 1.5e+08f의 값과 1.5e+08의 차이는 약 0.0이다.
        // 즉, 1.5e+08f는 1.5e+08과 거의 동일한 값을 나타낸다.
        // 1.5e+08f는 float형 숫자이고, 1.5e+08은 double형 숫자이다.
        // 1.5e+08f는 float형 숫자이므로, 소수점 이하의 자릿수가 제한된다.
        // 하지만 두 값이 서로 다르다고 표현하는 이유는, float형이 double형보다 더 적은 메모리를 사용하기 때문이다.
        // 두 값의 차이만 따진다면, 두 값은 완전히 동일한 값을 나타낼 수 있다.
        // 유니티에서는 1.5e+08과 1.5e+08f는 서로 다른 값으로 인식한다. 
        // 이것을 더블형으로 나타내면, 150000000.0이다.
        // 반면, float형으로 나타내면, 1.5e+08이다.
        // double형이 더블형이라면, float형은 플롯형이라고 할 수 있다.
        // 1.5e+08은 1.5 곱하기 10의 8제곱이라는 뜻이다.
        // 즉, 1.5 곱하기 100000000이라는 뜻이다.
        // 따라서, 1.5e+08은 150000000.0과 동일한 값을 나타낸다.
        // 한 줄 요약: f는 float형을 나타낸다. float형은 소수점을 포함한 숫자를 나타낸다(float에서 f 반드시 써야 함!).
        // 
        // Vector3.right는 캐릭터가 오른쪽으로 움직이려는 방향을 나타낸다.
        // Vector3.right를 다르게 쓰는 방법은 new Vector3(1, 0, 0)이다.
        // 이것을 또 다르게 오류 없이 쓰는 방법은 new Vector3(1f, 0f, 0f)이다.
        // 즉, 'transform.position += Vector3.right * 0.05f;'와 'transform.position += new Vector3(1, 0, 0) * 0.05f;'와 'transform.position += new Vector3(1f, 0f, 0f) * 0.05f;'는 모두 동일한 값을 나타낸다.
        // 따라서 이 세 가지 중 하나를 사용해도 문제는 없다.
        // 즉 캐릭터를 움직일 수 있는 방법은 세 가지가 있다는 뜻이다.
        // 이 세 가지 말고 다른 방법은 없다.
        // 캐릭터를 움직이게 할 때 가장 간단하게 쓴다면, Vector3.right를 사용하는 것이 가장 간단하다.
        // 2차원의 공간에서 Vector3.right를 사용하는 방법은 없다.
        // 2차원의 공간에서는 Vector2.right를 사용해야 한다.
        // 따라서 유니티에서 2차원의 게임을 만들 때 Vector3.right를 사용하면, 오류가 발생한다.
        // new Vector3에서 new는 '새로운 객체를 생성한다'라는 뜻이다.
        // Vector3 앞에 new가 붙는 이유는, Vector3가 클래스이기 때문이다.
        // Vector3 앞에 new를 사용하지 않으면, 오류가 발생한다.
        // 그 이유는, 클래스는 반드시 new를 사용하여 새로운 객체를 생성해야 하기 때문이다.
        // 이것을 다르게 표현하면, Vector3.right는 (1, 0, 0)이라는 벡터를 나타낸다.
        // (x, y, z)에서 x는 오른쪽 방향을 나타내고, y는 위쪽 방향을 나타내고, z는 앞쪽 방향을 나타낸다.
        // 예를 들어, Vector3.left는 (-1, 0, 0)이라는 벡터를 나타낸다.
        // (-1, 0, 0)에서 -1은 왼쪽 방향을 나타낸다.
        // (0, 0, 0)은 벡터가 없다는 뜻이다.
        // 벡터를 쉽게 말하면, '방향과 크기를 가진 물리량'이라고 생각하면 된다.
        // 벡터가 없다는 것은, 방향과 크기가 모두 0이라는 뜻이다.
        // 크기는 0이지만 '방향'이 있는 벡터는 존재하지 않는다.
        // 그 이유는, 크기가 0인 벡터는 방향이 없기 때문이다.
        // 반대로, 방향이 있지만 크기가 0인 벡터는 존재하지 않는다.
        // 그 이유는, 크기가 0인 벡터는 방향이 없기 때문이다.
        // 크기는 0이지만 방향이 없는 벡터는 존재한다.
        // 그 이유는, 크기가 0인 벡터는 방향이 없기 때문이다.
        // 이해를 돕기 위해, 벡터의 예를 들어보자.
        // 예를 들어, (3, 4, 0)이라는 벡터가 있다고 하자.
        // (3, 4, 0)에서 3은 오른쪽 방향을 나타내고, 4는 위쪽 방향을 나타내고, 0은 앞쪽 방향을 나타낸다.
        // 사람의 눈으로 정면으로 볼 때, (3, 4, 0)이라는 벡터는 오른쪽으로 3만큼, 위쪽으로 4만큼 움직인다는 뜻이다.
        // (3, 4, 0)이 아니라 (3, 4, 5)라는 벡터가 있다고 하자.
        // (3, 4, 5)에서 3은 오른쪽 방향을 나타내고, 4는 위쪽 방향을 나타내고, 5는 앞쪽 방향을 나타낸다.
        // 사람의 눈으로 정면으로 볼 때, (3, 4, 5)라는 벡터는 오른쪽으로 3만큼, 위쪽으로 4만큼, 앞쪽으로 5만큼 움직인다는 뜻이다.
        // 이것을 2차원 공간에서는 (3, 4)라는 벡터로 나타낸다.
        // 2차원 공간에서는 z축이 없기 때문이다.
        // 반대로, 3차원 공간에서는 (3, 4, 5)라는 벡터로 나타낸다.
        // 3차원 공간에서 (3, 4)라는 벡터는 존재하지 않는다.
        // 그 이유는, 3차원 공간에서는 z축이 있기 때문이다.
        // 이것을 다르게 표현하면, 3차원 공간에서는 (3, 4, 0)이라는 벡터로 나타낸다.
        // 이때, (3, 4, 5)라는 벡터에서, 크기와 방향의 값은 다음과 같이 계산할 수 있다.
        // 크기 = √(3^2 + 4^2 + 5^2) = √(9 + 16 + 25) = √50 ≈ 7.07
        // 방향 = (3/√50, 4/√50, 5/√50) ≈ (0.42, 0.57, 0.71)
        // 크기에서의 √(3^2 + 4^2 + 5^2)는 피타고라스의 정리를 3차원 공간에 확장한 것이다.
        // 방향에서의 (3/√50, 4/√50, 5/√50)는 벡터를 단위 벡터로 정규화한 것이다.
        // 크기에서의 √(9 + 16 + 25)는 3, 4, 5의 제곱을 더한 것이다.
        // 따라서, √50은 50의 제곱근이다.
        // 방향에서의 (3/√50, 4/√50, 5/√50)는 각 성분을 크기로 나눈 것이다.
        // 루트 50으로 나누는 이유는, 크기가 √50이기 때문이다.
        // 크기의 값에서 방향으로 나누는 이유는, 벡터를 단위 벡터로 정규화하기 위해서이다.
        // 크기의 겂에서 방향으로 나눈 값은 단위 벡터의 성분을 나타낸다.
        // 단위 벡터는 크기가 1인 벡터이다.
        // 단위 벡터는 방향만을 나타내기 때문에, 크기가 1이다.
        // 단위 벡터는 벡터의 방향을 나타내는 데 사용된다.
        // 단위 벡터가 없다면, 벡터의 방향을 나타낼 수 없다.
        // 단위 벡터는 벡터의 방향을 나타내는 데 매우 중요하다.
        // 단위 벡터는 벡터의 방향을 나타내는 데 사용되기 때문에, 단위 벡터가 없다면, 벡터의 방향을 나타낼 수 없다.
        // 또한, (0, 0, 0)이라는 벡터도 존재한다.
        // (0, 0, 0)이라는 벡터는 크기가 0이고, 방향이 없는 벡터이다.
        // 크기와 방향이 모두 없는 백터는 존재하지 않는다.
        // 한 줄 요약: Vector3.right는 캐릭터가 오른쪽으로 움직이려는 방향을 나타낸다.
        //
        // transform.position += Vector3.right * 0.05f;는 캐릭터가 오른쪽으로 0.05f만큼 움직인다는 뜻이다.
        // 캐릭터를 오른쪽으로 움직이려면 Vector3.right를 사용하고, 왼쪽으로 움직이려면 Vector3.left를 사용한다.
        // 또한 위로 움직이려면 Vector3.up을 사용하고, 아래로 움직이려면 Vector3.down을 사용한다(강사님께서 알려주지 않으신 부분).
        // 캐릭터를 움직이려면 transform.position을 사용한다.
        // transform.position은 캐릭터의 위치를 나타낸다.
        // +=는 '오른쪽에 있는 값을 왼쪽에 있는 값에 더한다'라는 뜻이다.
        // 이것을 쉽게 말하면, '캐릭터의 위치에 오른쪽 방향으로 0.05f만큼 더한다'라는 뜻이다.
        // 반대로 -=는 '오른쪽에 있는 값을 왼쪽에 있는 값에서 뺀다'라는 뜻이다.
        // 이것을 쉽게 말하면, '캐릭터의 위치에서 오른쪽 방향으로 0.05f만큼 뺀다'라는 뜻이다.
        // 오른쪽 방향으로 0.05f만큼 뺀다는 것은, 캐릭터가 왼쪽으로 0.05f만큼 움직인다는 뜻이다.
        // 반대로, 캐릭터의 위치에 오른쪽 방향으로 0.05f만큼 더한다는 것은, 캐릭터가 오른쪽으로 0.05f만큼 움직인다는 뜻이다.
        // 3f나 3미터이므로, 0.05f는 5센티미터이다.
        // 캐릭터의 키가 1미터, 즉 1f이면, 0.05f는 캐릭터의 키의 1/20이다.
        // * 0.05f를 사용하지 않으면, 캐릭터가 너무 빨리 움직이게 된다.
        // 예를 들어, transform.position += Vector3.right;라고 작성하면, 캐릭터가 매 프레임마다 1f만큼 움직이게 된다.
        // 이 속도는 캐릭터에게는 너무 빠른 속도이다.
        // 캐릭터의 보통의 속도를 내게 하려면, * 0.1f 이하의 값을 사용해야 한다.
        // * 0.1f의 속도는 캐릭터의 키가 1미터일 때, 캐릭터가 1초에 6미터를 움직이는 속도이다.
        // 캐릭터가 1초에 6미터를 움직이는 속도는 캐릭터에게는 적당한 속도이다.
        // 캐릭터에게 * 0.05f의 속도를 부여했으므로, 캐릭터는 1초에 3미터를 움직이게 된다.
        // transform.position += Vector3.right * 0.05f;는 캐릭터가 매 프레임마다 오른쪽으로 0.05f만큼 움직인다는 뜻이다.
        // Update()는 매 프레임마다 호출되기 때문이다.
        // 따라서, 캐릭터는 1초에 60프레임이므로, 1초에 0.05f * 60 = 3f만큼 움직이게 된다.
        // 3f를 쉬운 말로 하면, 3미터이다.
        // 캐릭터의 키를 생각하면, 3미터는 꽤 먼 거리이다.
        // 유니티에서, 한 칸당 1미터이다.
        // 캐릭터의 키가 1칸이면, 캐릭터의 키는 1미터이다.(3강, 22분 28초)
    }
}
